/**
 * MAAS API
 * This is the Mobility as a Service API
 *
 * OpenAPI spec version: 1.0.0
 * Contact: avalls@nexusgeographics.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import {
    HttpClient, HttpHeaders, HttpParams,
    HttpResponse, HttpEvent
} from '@angular/common/http';
import { CustomHttpUrlEncodingCodec } from '../encoder';

import { Observable } from 'rxjs/Observable';

import { Annulation } from '../model/annulation';
import { RefundData } from '../model/refundData';
import { Ticket } from '../model/ticket';
import { Transaction } from '../model/transaction';

import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';
import { PagedTransactions } from '../model/pagedTransactions';
import { query } from '@angular/animations';
import { config } from 'config/config';
import { TicketDetailed } from '../model/ticketDetailed';


@Injectable()
export class TicketsService {

    protected basePath = 'http://maas.nexusgeografics.com/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Get annulation details
     * Returns annulation details, included if the complaint is annullable.
     * @param annulationId 
     * @param authorization Token of authentication
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public annulation(annulationId: number, authorization: string, observe?: 'body', reportProgress?: boolean): Observable<Annulation>;
    public annulation(annulationId: number, authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Annulation>>;
    public annulation(annulationId: number, authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Annulation>>;
    public annulation(annulationId: number, authorization: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (annulationId === null || annulationId === undefined) {
            throw new Error('Required parameter annulationId was null or undefined when calling annulation.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling annulation.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Annulation>(`${this.basePath}/fines/annulation/${encodeURIComponent(String(annulationId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }


    /**
     * Get tickets by filters
     * 
     * @param startDate 
     * @param authorization Token of authentication
     * @param max Maximun number of tickets to return. Returns all the tickets if not set or 0
     * @param sort Sorting method applied to the list of tickets. Applied before the \&quot;max\&quot;. Dates are ordered descending.
     * @param endDate 
     * @param startDateMin Start date minimum range in unix time.
     * @param startDateMax Start date maximum range in unix time.
     * @param endDateMin End date minimum range in unix time.
     * @param endDateMax End date maximum range in unix time.
     * @param tickets List of ticket ids to search for.
     * @param plateNumbers Plate number to search for. Filter compatible with other params.
     * @param users List of userIds to search for. Not  required for unipersonal users, as the search will be done with the userId from the bearer token and this param will be skipped. Only available to fleet admin users.  Not compatible with the thirduserId parameter.
     * @param services Service filter
     * @param cities CityId filter
     * @param zoneTypes List of zoneTypeId
     * @param ticketTypes 
     * @param email ONLY BO: By user email or gremi email
     * @param userStateId ONLY BO: By user state id
     * @param nif ONLY BO: By user nif or gremi nif
     * @param phoneNumber ONLY BO: By user phone number or gremi phone number.
     * @param guildId ONLY BO: By gremi id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllTickets(startDate: Date, authorization: string, max?: number, sort?: string, endDate?: Date, startDateMin?: Date, startDateMax?: Date, endDateMin?: Date, endDateMax?: Date, tickets?: Array<number>, plateNumbers?: Array<string>, users?: Array<string>, services?: Array<number>, cities?: Array<number>, zoneTypes?: Array<string>, ticketTypes?: Array<number>, email?: string, userStateId?: string, nif?: string, phoneNumber?: string, guildId?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Ticket>>;
    public getAllTickets(startDate: Date, authorization: string, max?: number, sort?: string, endDate?: Date, startDateMin?: Date, startDateMax?: Date, endDateMin?: Date, endDateMax?: Date, tickets?: Array<number>, plateNumbers?: Array<string>, users?: Array<string>, services?: Array<number>, cities?: Array<number>, zoneTypes?: Array<string>, ticketTypes?: Array<number>, email?: string, userStateId?: string, nif?: string, phoneNumber?: string, guildId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Ticket>>>;
    public getAllTickets(startDate: Date, authorization: string, max?: number, sort?: string, endDate?: Date, startDateMin?: Date, startDateMax?: Date, endDateMin?: Date, endDateMax?: Date, tickets?: Array<number>, plateNumbers?: Array<string>, users?: Array<string>, services?: Array<number>, cities?: Array<number>, zoneTypes?: Array<string>, ticketTypes?: Array<number>, email?: string, userStateId?: string, nif?: string, phoneNumber?: string, guildId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Ticket>>>;
    public getAllTickets(startDate: Date, authorization: string, max?: number, sort?: string, endDate?: Date, startDateMin?: Date, startDateMax?: Date, endDateMin?: Date, endDateMax?: Date, tickets?: Array<number>, plateNumbers?: Array<string>, users?: Array<string>, services?: Array<number>, cities?: Array<number>, zoneTypes?: Array<string>, ticketTypes?: Array<number>, email?: string, userStateId?: string, nif?: string, phoneNumber?: string, guildId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getAllTickets.');
        }




















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (max !== undefined && max !== null) {
            queryParameters = queryParameters.set('max', <any>max);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('startDate', <any>startDate.toISOString());
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('endDate', <any>endDate.toISOString());
        }
        if (startDateMin !== undefined && startDateMin !== null) {
            queryParameters = queryParameters.set('startDateMin', <any>startDateMin.toISOString());
        }
        if (startDateMax !== undefined && startDateMax !== null) {
            queryParameters = queryParameters.set('startDateMax', <any>startDateMax.toISOString());
        }
        if (endDateMin !== undefined && endDateMin !== null) {
            queryParameters = queryParameters.set('endDateMin', <any>endDateMin.toISOString());
        }
        if (endDateMax !== undefined && endDateMax !== null) {
            queryParameters = queryParameters.set('endDateMax', <any>endDateMax.toISOString());
        }
        if (tickets) {
            tickets.forEach((element) => {
                queryParameters = queryParameters.append('tickets', <any>element);
            })
        }
        if (plateNumbers) {
            plateNumbers.forEach((element) => {
                queryParameters = queryParameters.append('plateNumbers', <any>element);
            })
        }
        if (users) {
            users.forEach((element) => {
                queryParameters = queryParameters.append('users', <any>element);
            })
        }
        if (services) {
            services.forEach((element) => {
                queryParameters = queryParameters.append('services', <any>element);
            })
        }
        if (cities) {
            cities.forEach((element) => {
                queryParameters = queryParameters.append('cities', <any>element);
            })
        }
        if (zoneTypes) {
            zoneTypes.forEach((element) => {
                queryParameters = queryParameters.append('zoneTypes', <any>element);
            })
        }
        if (ticketTypes) {
            ticketTypes.forEach((element) => {
                queryParameters = queryParameters.append('ticketTypes', <any>element);
            })
        }
        if (email !== undefined && email !== null) {
            queryParameters = queryParameters.set('email', <any>email);
        }
        if (userStateId !== undefined && userStateId !== null) {
            queryParameters = queryParameters.set('userStateId', <any>userStateId);
        }
        if (nif !== undefined && nif !== null) {
            queryParameters = queryParameters.set('nif', <any>nif);
        }
        if (phoneNumber !== undefined && phoneNumber !== null) {
            queryParameters = queryParameters.set('phoneNumber', <any>phoneNumber);
        }
        if (guildId !== undefined && guildId !== null) {
            queryParameters = queryParameters.set('guildId', <any>guildId);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (DUM Token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Ticket>>(`${this.basePath}/tickets`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }


    /**
     * Get monthly receipt for users
     * Monthly receipt for users, that includes the balance and usage for the user and it&#39;s fleet.
     * @param year 
     * @param month 
     * @param authorization Token of authentication
     * @param accountId To be uses in the BO MAAS
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public monthlyExtract(year: string, month: number, authorization: string, accountId?: number, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public monthlyExtract(year: string, month: number, authorization: string, accountId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public monthlyExtract(year: string, month: number, authorization: string, accountId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public monthlyExtract(year: string, month: number, authorization: string, accountId?: number, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (year === null || year === undefined) {
            throw new Error('Required parameter year was null or undefined when calling monthlyExtract.');
        }
        if (month === null || month === undefined) {
            throw new Error('Required parameter month was null or undefined when calling monthlyExtract.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling monthlyExtract.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (accountId !== undefined) {
            queryParameters = queryParameters.set('accountId', <any>accountId);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json, text/plain, */*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        headers = headers.set('Content-Type', 'application/pdf');

        return this.httpClient.get<any>(`${this.basePath}/monthlyExtracts/${encodeURIComponent(String(year))}/${encodeURIComponent(String(month))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress,
                responseType: 'blob' as 'json'
            }
        );
    }

    /**
     * Get monthly receipt by city.
     * Monthly receipt by city
     * @param cityId 
     * @param year 
     * @param month 
     * @param authorization Token of authentication
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public monthlyExtractByCity(cityId: number, year: number, month: number, authorization: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public monthlyExtractByCity(cityId: number, year: number, month: number, authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public monthlyExtractByCity(cityId: number, year: number, month: number, authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public monthlyExtractByCity(cityId: number, year: number, month: number, authorization: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling monthlyExtractByCity.');
        }
        if (year === null || year === undefined) {
            throw new Error('Required parameter year was null or undefined when calling monthlyExtractByCity.');
        }
        if (month === null || month === undefined) {
            throw new Error('Required parameter month was null or undefined when calling monthlyExtractByCity.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling monthlyExtractByCity.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json, text/plain, */*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        headers = headers.set('Content-Type', 'application/pdf');

        return this.httpClient.get<any>(`${this.basePath}/monthlyExtracts/${encodeURIComponent(String(cityId))}/${encodeURIComponent(String(year))}/${encodeURIComponent(String(month))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress,
                responseType: 'blob' as 'json'
            }
        );
    }

    /**
     * Pay annulation
     * 
     * @param annulationId 
     * @param authorization Token of authentication
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public payAnnulation(annulationId: number, authorization: string, observe?: 'body', reportProgress?: boolean): Observable<Ticket>;
    public payAnnulation(annulationId: number, authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Ticket>>;
    public payAnnulation(annulationId: number, authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Ticket>>;
    public payAnnulation(annulationId: number, authorization: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (annulationId === null || annulationId === undefined) {
            throw new Error('Required parameter annulationId was null or undefined when calling payAnnulation.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling payAnnulation.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.put<Ticket>(`${this.basePath}/fines/annulation/${encodeURIComponent(String(annulationId))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Refund all or part of a ticket
     * 
     * @param authorization Token of authentication
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public refundTicket(authorization: string, body: RefundData, observe?: 'body', reportProgress?: boolean): Observable<Ticket>;
    public refundTicket(authorization: string, body: RefundData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Ticket>>;
    public refundTicket(authorization: string, body: RefundData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Ticket>>;
    public refundTicket(authorization: string, body: RefundData, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling refundTicket.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling refundTicket.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<Ticket>(`${this.basePath}/refunds`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get annulation details
     * Returns annulation details, included if the complaint is annullable.
     * @param annulationId 
     * @param locale Default &#39;es&#39;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public thirdAnnulation(annulationId: number, locale?: string, observe?: 'body', reportProgress?: boolean): Observable<Annulation>;
    public thirdAnnulation(annulationId: number, locale?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Annulation>>;
    public thirdAnnulation(annulationId: number, locale?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Annulation>>;
    public thirdAnnulation(annulationId: number, locale?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (annulationId === null || annulationId === undefined) {
            throw new Error('Required parameter annulationId was null or undefined when calling thirdAnnulation.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (locale !== undefined) {
            queryParameters = queryParameters.set('locale', <any>locale);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Annulation>(`${this.basePath}/thirdparty/fines/annulation/${encodeURIComponent(String(annulationId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Pay annulation
     * 
     * @param annulationId 
     * @param locale Default &#39;es&#39;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public thirdPayAnnulation(annulationId: number, locale?: string, observe?: 'body', reportProgress?: boolean): Observable<Ticket>;
    public thirdPayAnnulation(annulationId: number, locale?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Ticket>>;
    public thirdPayAnnulation(annulationId: number, locale?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Ticket>>;
    public thirdPayAnnulation(annulationId: number, locale?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (annulationId === null || annulationId === undefined) {
            throw new Error('Required parameter annulationId was null or undefined when calling thirdPayAnnulation.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (locale !== undefined) {
            queryParameters = queryParameters.set('locale', <any>locale);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.put<Ticket>(`${this.basePath}/thirdparty/fines/annulation/${encodeURIComponent(String(annulationId))}`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get monthly receipt for third user
     * Monthly receipt for third user, that includes the balance and usage
     * @param year Year with four digits
     * @param month 1..12
     * @param authorization Token of authentication
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public thirdUsersMonthlyExtract(year: string, month: number, authorization: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public thirdUsersMonthlyExtract(year: string, month: number, authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public thirdUsersMonthlyExtract(year: string, month: number, authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public thirdUsersMonthlyExtract(year: string, month: number, authorization: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (year === null || year === undefined) {
            throw new Error('Required parameter year was null or undefined when calling thirdUsersMonthlyExtract.');
        }
        if (month === null || month === undefined) {
            throw new Error('Required parameter month was null or undefined when calling thirdUsersMonthlyExtract.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling thirdUsersMonthlyExtract.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/pdf'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<any>(`${this.basePath}/thirdusers/monthlyExtracts/${encodeURIComponent(String(year))}/${encodeURIComponent(String(month))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a ticket
     * Content-Type: * application/pdf * application/json
     * @param movementId 
     * @param authorization Token of authentication
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public ticket(movementId: number, authorization: string, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public ticket(movementId: number, authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public ticket(movementId: number, authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public ticket(movementId: number, authorization: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (movementId === null || movementId === undefined) {
            throw new Error('Required parameter movementId was null or undefined when calling ticket.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling ticket.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Content-Type header
        headers = headers.set('Content-Type', 'application/pdf');

        return this.httpClient.get<Ticket>(`${this.basePath}/tickets/${encodeURIComponent(String(movementId))}/pdf`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress,
                responseType: 'blob' as 'json'
            }
        );
    }

    /**
     * Get tickets by filters
     * 
     * @param authorization Token of authentication
     * @param startDate DateTime in unix format
     * @param endDate DateTime in unix format
     * @param zoneTypeId 
     * @param plateNumber 
     * @param userId This param is for the admin fleet.
     * @param ticketType 
     * @param max Maximun number of tickets to return. Returns all the tickets if not set or 0
     * @param ticketsId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tickets(authorization: string, startDate?: Date, endDate?: Date, zoneTypeId?: Array<string>, plateNumber?: Array<string>, userId?: Array<string>, ticketType?: Array<number>, max?: number, ticketsId?: Array<string>, thirdUserId?: number, cityId?: Array<number>, startDateMin?: Date, startDateMax?: Date, endDateMin?: Date, endDateMax?: Date,
        email?: string, userStateId?: string, nif?: string, telefon?: string, gremi?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Ticket>>;
    public tickets(authorization: string, startDate?: Date, endDate?: Date, zoneTypeId?: Array<string>, plateNumber?: Array<string>, userId?: Array<string>, ticketType?: Array<number>, max?: number, ticketsId?: Array<string>, thirdUserId?: number, cityId?: Array<number>, startDateMin?: Date, startDateMax?: Date, endDateMin?: Date, endDateMax?: Date,
        email?: string, userStateId?: string, nif?: string, telefon?: string, gremi?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Ticket>>>;
    public tickets(authorization: string, startDate?: Date, endDate?: Date, zoneTypeId?: Array<string>, plateNumber?: Array<string>, userId?: Array<string>, ticketType?: Array<number>, max?: number, ticketsId?: Array<string>, thirdUserId?: number, cityId?: Array<number>, startDateMin?: Date, startDateMax?: Date, endDateMin?: Date, endDateMax?: Date,
        email?: string, userStateId?: string, nif?: string, telefon?: string, gremi?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Ticket>>>;
    public tickets(authorization: string, startDate?: Date, endDate?: Date, zoneTypeId?: Array<string>, plateNumber?: Array<string>, userId?: Array<string>, ticketType?: Array<number>, max?: number, ticketsId?: Array<string>, thirdUserId?: number, cityId?: Array<number>, startDateMin?: Date, startDateMax?: Date, endDateMin?: Date, endDateMax?: Date,
        email?: string, userStateId?: string, nif?: string, telefon?: string, gremi?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        max = config.MAX_TICKETS;

        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling tickets.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (startDate !== undefined) {
            queryParameters = queryParameters.set('startDate', <any>startDate.toISOString());
        }
        if (endDate !== undefined) {
            queryParameters = queryParameters.set('endDate', <any>endDate.toISOString());
        }
        if (startDateMin !== undefined) {
            queryParameters = queryParameters.set('startDateMin', <any>startDateMin.toISOString());
        }
        if (startDateMax !== undefined) {
            queryParameters = queryParameters.set('startDateMax', <any>startDateMax.toISOString());
        }
        if (endDateMin !== undefined) {
            queryParameters = queryParameters.set('endDateMin', <any>endDateMin.toISOString());
        }
        if (endDateMax !== undefined) {
            queryParameters = queryParameters.set('endDateMax', <any>endDateMax.toISOString());
        }
        if (zoneTypeId) {
            zoneTypeId.forEach((element) => {
                queryParameters = queryParameters.append('zoneTypeId', <any>element);
            })
        }
        if (cityId) {
            cityId.forEach((element) => {
                queryParameters = queryParameters.append('cityId', <any>element);
            })
        }
        if (plateNumber) {
            plateNumber.forEach((element) => {
                queryParameters = queryParameters.append('plateNumber', <any>element);
            })
        }
        if (userId) {
            userId.forEach((element) => {
                queryParameters = queryParameters.append('userId', <any>element);
            })
        }
        if (ticketType) {
            ticketType.forEach((element) => {
                queryParameters = queryParameters.append('ticketType', <any>element);
            })
        }
        if (max !== undefined) {
            queryParameters = queryParameters.set('max', <any>max);
        }

        if (thirdUserId !== undefined) {
            queryParameters = queryParameters.set('thirduserId', <any>thirdUserId);
        }

        if (ticketsId) {
            ticketsId.forEach((element) => {
                queryParameters = queryParameters.append('ticketsId', <any>element);
            })
        }

        if (email !== undefined) {
            queryParameters = queryParameters.set('email', <any>email);
        }

        if (userStateId !== undefined) {
            queryParameters = queryParameters.set('userStateId', <any>userStateId);
        }

        if (nif !== undefined) {
            queryParameters = queryParameters.set('nif', <any>nif);
        }

        if (telefon !== undefined) {
            queryParameters = queryParameters.set('phoneNumber', <any>telefon);
        }

        if (gremi !== undefined) {
            queryParameters = queryParameters.set('guildId', <any>gremi);
        }


        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Ticket>>(`${this.basePath}/movements`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
    * Get tickets by filters
    * 
    * @param authorization Token of authentication
    * @param startDate DateTime in unix format
    * @param endDate DateTime in unix format
    * @param zoneTypeId 
    * @param plateNumber 
    * @param userId This param is for the admin fleet.
    * @param ticketType 
    * @param max Maximun number of tickets to return. Returns all the tickets if not set or 0
    * @param ticketsId 
    * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
    * @param reportProgress flag to report request and response progress.
    */
    public ticketsExcel(authorization: string, startDate?: Date, endDate?: Date, zoneTypeId?: Array<string>, plateNumber?: Array<string>, userId?: Array<string>, ticketType?: Array<number>, max?: number, ticketsId?: Array<string>, thirdUserId?: number, cityId?: Array<number>, startDateMin?: Date, startDateMax?: Date, endDateMin?: Date, endDateMax?: Date,
        email?: string, userStateId?: string, nif?: string, telefon?: string, gremi?: string, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public ticketsExcel(authorization: string, startDate?: Date, endDate?: Date, zoneTypeId?: Array<string>, plateNumber?: Array<string>, userId?: Array<string>, ticketType?: Array<number>, max?: number, ticketsId?: Array<string>, thirdUserId?: number, cityId?: Array<number>, startDateMin?: Date, startDateMax?: Date, endDateMin?: Date, endDateMax?: Date,
        email?: string, userStateId?: string, nif?: string, telefon?: string, gremi?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public ticketsExcel(authorization: string, startDate?: Date, endDate?: Date, zoneTypeId?: Array<string>, plateNumber?: Array<string>, userId?: Array<string>, ticketType?: Array<number>, max?: number, ticketsId?: Array<string>, thirdUserId?: number, cityId?: Array<number>, startDateMin?: Date, startDateMax?: Date, endDateMin?: Date, endDateMax?: Date,
        email?: string, userStateId?: string, nif?: string, telefon?: string, gremi?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public ticketsExcel(authorization: string, startDate?: Date, endDate?: Date, zoneTypeId?: Array<string>, plateNumber?: Array<string>, userId?: Array<string>, ticketType?: Array<number>, max?: number, ticketsId?: Array<string>, thirdUserId?: number, cityId?: Array<number>, startDateMin?: Date, startDateMax?: Date, endDateMin?: Date, endDateMax?: Date,
        email?: string, userStateId?: string, nif?: string, telefon?: string, gremi?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        max = config.MAX_TICKETS_EXPORT;

        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling tickets.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (startDate !== undefined) {
            queryParameters = queryParameters.set('startDate', <any>startDate.toISOString());
        }
        if (endDate !== undefined) {
            queryParameters = queryParameters.set('endDate', <any>endDate.toISOString());
        }
        if (startDateMin !== undefined) {
            queryParameters = queryParameters.set('startDateMin', <any>startDateMin.toISOString());
        }
        if (startDateMax !== undefined) {
            queryParameters = queryParameters.set('startDateMax', <any>startDateMax.toISOString());
        }
        if (endDateMin !== undefined) {
            queryParameters = queryParameters.set('endDateMin', <any>endDateMin.toISOString());
        }
        if (endDateMax !== undefined) {
            queryParameters = queryParameters.set('endDateMax', <any>endDateMax.toISOString());
        }
        if (zoneTypeId) {
            zoneTypeId.forEach((element) => {
                queryParameters = queryParameters.append('zoneTypes', <any>element);
            })
        }
        if (cityId) {
            cityId.forEach((element) => {
                queryParameters = queryParameters.append('cities', <any>element);
            })
        }
        if (plateNumber) {
            plateNumber.forEach((element) => {
                queryParameters = queryParameters.append('plateNumbers', <any>element);
            })
        }
        if (userId) {
            userId.forEach((element) => {
                queryParameters = queryParameters.append('users', <any>element);
            })
        }
        if (ticketType) {
            ticketType.forEach((element) => {
                queryParameters = queryParameters.append('ticketTypes', <any>element);
            })
        }
        if (max !== undefined) {
            queryParameters = queryParameters.set('max', <any>max);
        }

        if (ticketsId) {
            ticketsId.forEach((element) => {
                queryParameters = queryParameters.append('tickets', <any>element);
            })
        }

        if (email !== undefined) {
            queryParameters = queryParameters.set('email', <any>email);
        }

        if (userStateId !== undefined) {
            queryParameters = queryParameters.set('userStateId', <any>userStateId);
        }

        if (nif !== undefined) {
            queryParameters = queryParameters.set('nif', <any>nif);
        }

        if (telefon !== undefined) {
            queryParameters = queryParameters.set('telefon', <any>telefon);
        }

        if (gremi !== undefined) {
            queryParameters = queryParameters.set('gremi', <any>gremi);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        /*
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }
        */

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        headers = headers.set('Content-Type', 'application/vnd.ms-excel');

        return this.httpClient.get<Array<Ticket>>(`${this.basePath}/tickets/xls`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress,
                responseType: 'blob' as 'json'
            }
        );
    }

    /**
   * Get tickets by filters
   * 
   * @param authorization Token of authentication
   * @param startDate DateTime in unix format
   * @param endDate DateTime in unix format
   * @param zoneTypeId 
   * @param plateNumber 
   * @param userId This param is for the admin fleet.
   * @param ticketType 
   * @param max Maximun number of tickets to return. Returns all the tickets if not set or 0
   * @param ticketsId 
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
    public ticketsPdf(authorization: string, startDate?: Date, endDate?: Date, zoneTypeId?: Array<string>, plateNumber?: Array<string>, userId?: Array<string>, ticketType?: Array<number>, max?: number, ticketsId?: Array<string>, thirdUserId?: number, cityId?: Array<number>, startDateMin?: Date, startDateMax?: Date, endDateMin?: Date, endDateMax?: Date,
        email?: string, userStateId?: string, nif?: string, telefon?: string, gremi?: string, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public ticketsPdf(authorization: string, startDate?: Date, endDate?: Date, zoneTypeId?: Array<string>, plateNumber?: Array<string>, userId?: Array<string>, ticketType?: Array<number>, max?: number, ticketsId?: Array<string>, thirdUserId?: number, cityId?: Array<number>, startDateMin?: Date, startDateMax?: Date, endDateMin?: Date, endDateMax?: Date,
        email?: string, userStateId?: string, nif?: string, telefon?: string, gremi?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public ticketsPdf(authorization: string, startDate?: Date, endDate?: Date, zoneTypeId?: Array<string>, plateNumber?: Array<string>, userId?: Array<string>, ticketType?: Array<number>, max?: number, ticketsId?: Array<string>, thirdUserId?: number, cityId?: Array<number>, startDateMin?: Date, startDateMax?: Date, endDateMin?: Date, endDateMax?: Date,
        email?: string, userStateId?: string, nif?: string, telefon?: string, gremi?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public ticketsPdf(authorization: string, startDate?: Date, endDate?: Date, zoneTypeId?: Array<string>, plateNumber?: Array<string>, userId?: Array<string>, ticketType?: Array<number>, max?: number, ticketsId?: Array<string>, thirdUserId?: number, cityId?: Array<number>, startDateMin?: Date, startDateMax?: Date, endDateMin?: Date, endDateMax?: Date,
        email?: string, userStateId?: string, nif?: string, telefon?: string, gremi?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        max = config.MAX_TICKETS_EXPORT;

        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling tickets.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (startDate !== undefined) {
            queryParameters = queryParameters.set('startDate', <any>startDate.toISOString());
        }
        if (endDate !== undefined) {
            queryParameters = queryParameters.set('endDate', <any>endDate.toISOString());
        }
        if (startDateMin !== undefined) {
            queryParameters = queryParameters.set('startDateMin', <any>startDateMin.toISOString());
        }
        if (startDateMax !== undefined) {
            queryParameters = queryParameters.set('startDateMax', <any>startDateMax.toISOString());
        }
        if (endDateMin !== undefined) {
            queryParameters = queryParameters.set('endDateMin', <any>endDateMin.toISOString());
        }
        if (endDateMax !== undefined) {
            queryParameters = queryParameters.set('endDateMax', <any>endDateMax.toISOString());
        }
        if (zoneTypeId) {
            zoneTypeId.forEach((element) => {
                queryParameters = queryParameters.append('zoneTypes', <any>element);
            })
        }
        if (cityId) {
            cityId.forEach((element) => {
                queryParameters = queryParameters.append('cities', <any>element);
            })
        }
        if (plateNumber) {
            plateNumber.forEach((element) => {
                queryParameters = queryParameters.append('plateNumbers', <any>element);
            })
        }
        if (userId) {
            userId.forEach((element) => {
                queryParameters = queryParameters.append('users', <any>element);
            })
        }
        if (ticketType) {
            ticketType.forEach((element) => {
                queryParameters = queryParameters.append('ticketTypes', <any>element);
            })
        }
        if (max !== undefined) {
            queryParameters = queryParameters.set('max', <any>max);
        }

        if (ticketsId) {
            ticketsId.forEach((element) => {
                queryParameters = queryParameters.append('tickets', <any>element);
            })
        }

        if (email !== undefined) {
            queryParameters = queryParameters.set('email', <any>email);
        }

        if (userStateId !== undefined) {
            queryParameters = queryParameters.set('userStateId', <any>userStateId);
        }

        if (nif !== undefined) {
            queryParameters = queryParameters.set('nif', <any>nif);
        }

        if (telefon !== undefined) {
            queryParameters = queryParameters.set('telefon', <any>telefon);
        }

        if (gremi !== undefined) {
            queryParameters = queryParameters.set('gremi', <any>gremi);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        /*
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }
        */

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        headers = headers.set('Content-Type', 'application/pdf');

        return this.httpClient.get<Array<Ticket>>(`${this.basePath}/tickets/pdf`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress,
                responseType: 'blob' as 'json'
            }
        );
    }


    /**
     * Get tickets by filters
     * 
     * @param ticketsId 
     * @param authorization Token of authentication
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public ticketsMailer(ticketsId: Array<number>, authorization: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public ticketsMailer(ticketsId: Array<number>, authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public ticketsMailer(ticketsId: Array<number>, authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public ticketsMailer(ticketsId: Array<number>, authorization: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (ticketsId === null || ticketsId === undefined) {
            throw new Error('Required parameter ticketsId was null or undefined when calling ticketsMailer.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling ticketsMailer.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (ticketsId) {
            ticketsId.forEach((element) => {
                queryParameters = queryParameters.append('ticketsId', <any>element);
            })
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<any>(`${this.basePath}/movements/mail`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
    * Get a detailed ticket
    * This method returns a detailed ticket with all the configuration.  It&#39;s slower than the non detailed because extra queries must be done to get configurations. Only use it if configuration is a must.
    * @param movementId 
    * @param authorization Token of authentication
    * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
    * @param reportProgress flag to report request and response progress.
    */
    public ticketDetailed(movementId: number, authorization: string, observe?: 'body', reportProgress?: boolean): Observable<TicketDetailed>;
    public ticketDetailed(movementId: number, authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TicketDetailed>>;
    public ticketDetailed(movementId: number, authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TicketDetailed>>;
    public ticketDetailed(movementId: number, authorization: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (movementId === null || movementId === undefined) {
            throw new Error('Required parameter movementId was null or undefined when calling ticketDetailed.');
        }

        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling ticketDetailed.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<TicketDetailed>(`${this.basePath}/movements/${encodeURIComponent(String(movementId))}/detailed`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }


    /**
     * Get a transaction
     * 
     * @param transactionId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public transaction(transactionId: number, observe?: 'body', reportProgress?: boolean): Observable<Transaction>;
    public transaction(transactionId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Transaction>>;
    public transaction(transactionId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Transaction>>;
    public transaction(transactionId: number, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling transaction.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Transaction>(`${this.basePath}/transactions/${encodeURIComponent(String(transactionId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }


    /**
     * Get bank transactions
     * One of the filters are mandatory
     * @param page Page number. For pagination purposes
     * @param size Number of elements for page .For pagination purposes
     * @param authorization Token of authentication
     * @param userId 
     * @param startDate Show transactions from specific date.
     * @param endDate Show transactions to specific date
     * @param transTypeIds 
     * @param transStatusIds 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public transactions(page: number, size: number, authorization: string, userId?: number, startDate?: Date, endDate?: Date, transTypeIds?: Array<number>, transStatusIds?: Array<number>, ticketIds?: Array<number>, observe?: 'body', reportProgress?: boolean): Observable<PagedTransactions>;
    public transactions(page: number, size: number, authorization: string, userId?: number, startDate?: Date, endDate?: Date, transTypeIds?: Array<number>, transStatusIds?: Array<number>, ticketIds?: Array<number>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedTransactions>>;
    public transactions(page: number, size: number, authorization: string, userId?: number, startDate?: Date, endDate?: Date, transTypeIds?: Array<number>, transStatusIds?: Array<number>, ticketIds?: Array<number>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedTransactions>>;
    public transactions(page: number, size: number, authorization: string, userId?: number, startDate?: Date, endDate?: Date, transTypeIds?: Array<number>, transStatusIds?: Array<number>, ticketIds?: Array<number>, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling transactions.');
        }

        if (size === null || size === undefined) {
            throw new Error('Required parameter size was null or undefined when calling transactions.');
        }

        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling transactions.');
        }






        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', <any>userId);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('startDate', <any>startDate.toISOString());
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('endDate', <any>endDate.toISOString());
        }
        if (transTypeIds) {
            transTypeIds.forEach((element) => {
                queryParameters = queryParameters.append('transTypeIds', <any>element);
            })
        }
        if (transStatusIds) {
            transStatusIds.forEach((element) => {
                queryParameters = queryParameters.append('transStatusIds', <any>element);
            })
        }
        if (ticketIds) {
            ticketIds.forEach((element) => {
                queryParameters = queryParameters.append('ticketIds', <any>element);
            })
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<PagedTransactions>(`${this.basePath}/transactions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a single ticket with more info
     * 
     * @param ticketId 
     * @param authorization Token of authentication
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public payTicket(ticketId: number, authorization: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public payTicket(ticketId: number, authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public payTicket(ticketId: number, authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public payTicket(ticketId: number, authorization: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (ticketId === null || ticketId === undefined) {
            throw new Error('Required parameter ticketId was null or undefined when calling getTicket.');
        }

        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getTicket.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<any>(`${this.basePath}/tickets/${encodeURIComponent(String(ticketId))}/pay`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }


}
