/**
 * Smou API
 * This is the Mobility as a Service API
 *
 * OpenAPI spec version: 1.0.0
 * Contact: avalls@nexusgeographics.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { ConfigurationConf } from '../model/configurationConf';
import { ModifierConf } from '../model/modifierConf';
import { RateCityConf } from '../model/rateCityConf';
import { RestrictionConf } from '../model/restrictionConf';
import { ScheduleCityConf } from '../model/scheduleCityConf';
import { SegmentConf } from '../model/segmentConf';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class CityConfigService {

    protected basePath = 'http://maas.nexusgeografics.com/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Get the configuration
     * 
     * @param cityId 
     * @param configurationId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public configuration2(cityId: number, configurationId: number, observe?: 'body', reportProgress?: boolean): Observable<ConfigurationConf>;
    public configuration2(cityId: number, configurationId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ConfigurationConf>>;
    public configuration2(cityId: number, configurationId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ConfigurationConf>>;
    public configuration2(cityId: number, configurationId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling configuration.');
        }
        if (configurationId === null || configurationId === undefined) {
            throw new Error('Required parameter configurationId was null or undefined when calling configuration.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ConfigurationConf>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/configurations/${encodeURIComponent(String(configurationId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all configurations
     * 
     * @param cityId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public configurations(cityId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ConfigurationConf>>;
    public configurations(cityId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ConfigurationConf>>>;
    public configurations(cityId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ConfigurationConf>>>;
    public configurations(cityId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling configurations.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ConfigurationConf>>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/configurations`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a new configuration
     * 
     * @param cityId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createConfiguration(cityId: number, body: ConfigurationConf, observe?: 'body', reportProgress?: boolean): Observable<ConfigurationConf>;
    public createConfiguration(cityId: number, body: ConfigurationConf, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ConfigurationConf>>;
    public createConfiguration(cityId: number, body: ConfigurationConf, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ConfigurationConf>>;
    public createConfiguration(cityId: number, body: ConfigurationConf, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling createConfiguration.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createConfiguration.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<ConfigurationConf>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/configurations`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a new restriction
     * 
     * @param cityId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createRestriction(cityId: number, body: RestrictionConf, observe?: 'body', reportProgress?: boolean): Observable<RestrictionConf>;
    public createRestriction(cityId: number, body: RestrictionConf, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RestrictionConf>>;
    public createRestriction(cityId: number, body: RestrictionConf, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RestrictionConf>>;
    public createRestriction(cityId: number, body: RestrictionConf, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling createRestriction.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createRestriction.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<RestrictionConf>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/restrictions`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a new schedule
     * 
     * @param cityId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createSchedule(cityId: number, body: ScheduleCityConf, observe?: 'body', reportProgress?: boolean): Observable<ScheduleCityConf>;
    public createSchedule(cityId: number, body: ScheduleCityConf, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ScheduleCityConf>>;
    public createSchedule(cityId: number, body: ScheduleCityConf, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ScheduleCityConf>>;
    public createSchedule(cityId: number, body: ScheduleCityConf, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling createSchedule.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createSchedule.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<ScheduleCityConf>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/schedules`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a new schedule
     * 
     * @param cityId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createSegment(cityId: number, body: SegmentConf, observe?: 'body', reportProgress?: boolean): Observable<SegmentConf>;
    public createSegment(cityId: number, body: SegmentConf, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SegmentConf>>;
    public createSegment(cityId: number, body: SegmentConf, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SegmentConf>>;
    public createSegment(cityId: number, body: SegmentConf, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling createSegment.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createSegment.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<SegmentConf>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/segments`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a configuration
     * 
     * @param cityId 
     * @param configurationId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteConfiguration(cityId: number, configurationId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteConfiguration(cityId: number, configurationId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteConfiguration(cityId: number, configurationId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteConfiguration(cityId: number, configurationId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling deleteConfiguration.');
        }
        if (configurationId === null || configurationId === undefined) {
            throw new Error('Required parameter configurationId was null or undefined when calling deleteConfiguration.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/configurations/${encodeURIComponent(String(configurationId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
    * Create a new modifier
    * 
    * @param cityId 
    * @param body 
    * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
    * @param reportProgress flag to report request and response progress.
    */
   public createModifier(cityId: number, body: ModifierConf, observe?: 'body', reportProgress?: boolean): Observable<ModifierConf>;
   public createModifier(cityId: number, body: ModifierConf, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModifierConf>>;
   public createModifier(cityId: number, body: ModifierConf, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModifierConf>>;
   public createModifier(cityId: number, body: ModifierConf, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
       if (cityId === null || cityId === undefined) {
           throw new Error('Required parameter cityId was null or undefined when calling createModifier.');
       }
       if (body === null || body === undefined) {
           throw new Error('Required parameter body was null or undefined when calling createModifier.');
       }

       let headers = this.defaultHeaders;

       // authentication (MaaS Token) required
       if (this.configuration.accessToken) {
           let accessToken = typeof this.configuration.accessToken === 'function'
               ? this.configuration.accessToken()
               : this.configuration.accessToken;
           headers = headers.set('Authorization', 'Bearer ' + accessToken);
       }

       // to determine the Accept header
       let httpHeaderAccepts: string[] = [
           'application/json'
       ];
       let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
       if (httpHeaderAcceptSelected != undefined) {
           headers = headers.set("Accept", httpHeaderAcceptSelected);
       }

       // to determine the Content-Type header
       let consumes: string[] = [
       ];
       let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
       if (httpContentTypeSelected != undefined) {
           headers = headers.set("Content-Type", httpContentTypeSelected);
       }

       return this.httpClient.post<ModifierConf>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/modifiers`,
           body,
           {
               withCredentials: this.configuration.withCredentials,
               headers: headers,
               observe: observe,
               reportProgress: reportProgress
           }
       );
   }

   /**
    * Create a new rate
    * 
    * @param cityId 
    * @param body 
    * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
    * @param reportProgress flag to report request and response progress.
    */
   public createRate(cityId: number, body: RateCityConf, observe?: 'body', reportProgress?: boolean): Observable<RateCityConf>;
   public createRate(cityId: number, body: RateCityConf, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RateCityConf>>;
   public createRate(cityId: number, body: RateCityConf, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RateCityConf>>;
   public createRate(cityId: number, body: RateCityConf, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
       if (cityId === null || cityId === undefined) {
           throw new Error('Required parameter cityId was null or undefined when calling createRate.');
       }
       if (body === null || body === undefined) {
           throw new Error('Required parameter body was null or undefined when calling createRate.');
       }

       let headers = this.defaultHeaders;

       // authentication (MaaS Token) required
       if (this.configuration.accessToken) {
           let accessToken = typeof this.configuration.accessToken === 'function'
               ? this.configuration.accessToken()
               : this.configuration.accessToken;
           headers = headers.set('Authorization', 'Bearer ' + accessToken);
       }

       // to determine the Accept header
       let httpHeaderAccepts: string[] = [
           'application/json'
       ];
       let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
       if (httpHeaderAcceptSelected != undefined) {
           headers = headers.set("Accept", httpHeaderAcceptSelected);
       }

       // to determine the Content-Type header
       let consumes: string[] = [
       ];
       let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
       if (httpContentTypeSelected != undefined) {
           headers = headers.set("Content-Type", httpContentTypeSelected);
       }

       return this.httpClient.post<RateCityConf>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/rates`,
           body,
           {
               withCredentials: this.configuration.withCredentials,
               headers: headers,
               observe: observe,
               reportProgress: reportProgress
           }
       );
   }

    /**
     * Delete a modifier
     * 
     * @param cityId 
     * @param modifierId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteModifier(cityId: number, modifierId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteModifier(cityId: number, modifierId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteModifier(cityId: number, modifierId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteModifier(cityId: number, modifierId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling deleteModifier.');
        }
        if (modifierId === null || modifierId === undefined) {
            throw new Error('Required parameter modifierId was null or undefined when calling deleteModifier.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/modifiers/${encodeURIComponent(String(modifierId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a rate
     * 
     * @param cityId 
     * @param rateId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteRate(cityId: number, rateId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteRate(cityId: number, rateId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteRate(cityId: number, rateId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteRate(cityId: number, rateId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling deleteRate.');
        }
        if (rateId === null || rateId === undefined) {
            throw new Error('Required parameter rateId was null or undefined when calling deleteRate.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/rates/${encodeURIComponent(String(rateId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a restriction
     * 
     * @param cityId 
     * @param restrictionId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteRestriction(cityId: number, restrictionId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteRestriction(cityId: number, restrictionId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteRestriction(cityId: number, restrictionId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteRestriction(cityId: number, restrictionId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling deleteRestriction.');
        }
        if (restrictionId === null || restrictionId === undefined) {
            throw new Error('Required parameter restrictionId was null or undefined when calling deleteRestriction.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/restrictions/${encodeURIComponent(String(restrictionId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a schedule
     * 
     * @param cityId 
     * @param scheduleId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteSchedule(cityId: number, scheduleId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteSchedule(cityId: number, scheduleId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteSchedule(cityId: number, scheduleId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteSchedule(cityId: number, scheduleId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling deleteSchedule.');
        }
        if (scheduleId === null || scheduleId === undefined) {
            throw new Error('Required parameter scheduleId was null or undefined when calling deleteSchedule.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/schedules/${encodeURIComponent(String(scheduleId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a segment
     * 
     * @param cityId 
     * @param segmentId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteSegment(cityId: number, segmentId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteSegment(cityId: number, segmentId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteSegment(cityId: number, segmentId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteSegment(cityId: number, segmentId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling deleteSegment.');
        }
        if (segmentId === null || segmentId === undefined) {
            throw new Error('Required parameter segmentId was null or undefined when calling deleteSegment.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/segments/${encodeURIComponent(String(segmentId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit a configuration
     * 
     * @param cityId 
     * @param configurationId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public editConfiguration(cityId: number, configurationId: number, body: ConfigurationConf, observe?: 'body', reportProgress?: boolean): Observable<ConfigurationConf>;
    public editConfiguration(cityId: number, configurationId: number, body: ConfigurationConf, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ConfigurationConf>>;
    public editConfiguration(cityId: number, configurationId: number, body: ConfigurationConf, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ConfigurationConf>>;
    public editConfiguration(cityId: number, configurationId: number, body: ConfigurationConf, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling editConfiguration.');
        }
        if (configurationId === null || configurationId === undefined) {
            throw new Error('Required parameter configurationId was null or undefined when calling editConfiguration.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling editConfiguration.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<ConfigurationConf>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/configurations/${encodeURIComponent(String(configurationId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit a modifier
     * 
     * @param cityId 
     * @param modifierId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public editModifier(cityId: number, modifierId: number, body: ModifierConf, observe?: 'body', reportProgress?: boolean): Observable<ModifierConf>;
    public editModifier(cityId: number, modifierId: number, body: ModifierConf, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModifierConf>>;
    public editModifier(cityId: number, modifierId: number, body: ModifierConf, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModifierConf>>;
    public editModifier(cityId: number, modifierId: number, body: ModifierConf, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling editModifier.');
        }
        if (modifierId === null || modifierId === undefined) {
            throw new Error('Required parameter modifierId was null or undefined when calling editModifier.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling editModifier.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<ModifierConf>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/modifiers/${encodeURIComponent(String(modifierId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit a rate
     * 
     * @param cityId 
     * @param rateId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public editRate(cityId: number, rateId: number, body: RateCityConf, observe?: 'body', reportProgress?: boolean): Observable<RateCityConf>;
    public editRate(cityId: number, rateId: number, body: RateCityConf, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RateCityConf>>;
    public editRate(cityId: number, rateId: number, body: RateCityConf, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RateCityConf>>;
    public editRate(cityId: number, rateId: number, body: RateCityConf, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling editRate.');
        }
        if (rateId === null || rateId === undefined) {
            throw new Error('Required parameter rateId was null or undefined when calling editRate.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling editRate.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<RateCityConf>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/rates/${encodeURIComponent(String(rateId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit a restriction
     * 
     * @param cityId 
     * @param restrictionId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public editRestriction(cityId: number, restrictionId: number, body: RestrictionConf, observe?: 'body', reportProgress?: boolean): Observable<RestrictionConf>;
    public editRestriction(cityId: number, restrictionId: number, body: RestrictionConf, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RestrictionConf>>;
    public editRestriction(cityId: number, restrictionId: number, body: RestrictionConf, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RestrictionConf>>;
    public editRestriction(cityId: number, restrictionId: number, body: RestrictionConf, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling editRestriction.');
        }
        if (restrictionId === null || restrictionId === undefined) {
            throw new Error('Required parameter restrictionId was null or undefined when calling editRestriction.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling editRestriction.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<RestrictionConf>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/restrictions/${encodeURIComponent(String(restrictionId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit a schedule
     * 
     * @param cityId 
     * @param scheduleId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public editSchedule(cityId: number, scheduleId: number, body: ScheduleCityConf, observe?: 'body', reportProgress?: boolean): Observable<ScheduleCityConf>;
    public editSchedule(cityId: number, scheduleId: number, body: ScheduleCityConf, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ScheduleCityConf>>;
    public editSchedule(cityId: number, scheduleId: number, body: ScheduleCityConf, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ScheduleCityConf>>;
    public editSchedule(cityId: number, scheduleId: number, body: ScheduleCityConf, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling editSchedule.');
        }
        if (scheduleId === null || scheduleId === undefined) {
            throw new Error('Required parameter scheduleId was null or undefined when calling editSchedule.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling editSchedule.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<ScheduleCityConf>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/schedules/${encodeURIComponent(String(scheduleId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit a segment
     * 
     * @param cityId 
     * @param segmentId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public editSegment(cityId: number, segmentId: number, body: SegmentConf, observe?: 'body', reportProgress?: boolean): Observable<SegmentConf>;
    public editSegment(cityId: number, segmentId: number, body: SegmentConf, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SegmentConf>>;
    public editSegment(cityId: number, segmentId: number, body: SegmentConf, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SegmentConf>>;
    public editSegment(cityId: number, segmentId: number, body: SegmentConf, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling editSegment.');
        }
        if (segmentId === null || segmentId === undefined) {
            throw new Error('Required parameter segmentId was null or undefined when calling editSegment.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling editSegment.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<SegmentConf>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/segments/${encodeURIComponent(String(segmentId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a modifier
     * 
     * @param cityId 
     * @param modifierId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modifier(cityId: number, modifierId: number, observe?: 'body', reportProgress?: boolean): Observable<ModifierConf>;
    public modifier(cityId: number, modifierId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModifierConf>>;
    public modifier(cityId: number, modifierId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModifierConf>>;
    public modifier(cityId: number, modifierId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling modifier.');
        }
        if (modifierId === null || modifierId === undefined) {
            throw new Error('Required parameter modifierId was null or undefined when calling modifier.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ModifierConf>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/modifiers/${encodeURIComponent(String(modifierId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all the modifiers
     * 
     * @param cityId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modifiers(cityId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ModifierConf>>;
    public modifiers(cityId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModifierConf>>>;
    public modifiers(cityId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModifierConf>>>;
    public modifiers(cityId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling modifiers.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModifierConf>>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/modifiers`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a rate
     * 
     * @param cityId 
     * @param rateId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public rate(cityId: number, rateId: number, observe?: 'body', reportProgress?: boolean): Observable<RateCityConf>;
    public rate(cityId: number, rateId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RateCityConf>>;
    public rate(cityId: number, rateId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RateCityConf>>;
    public rate(cityId: number, rateId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling rate.');
        }
        if (rateId === null || rateId === undefined) {
            throw new Error('Required parameter rateId was null or undefined when calling rate.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<RateCityConf>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/rates/${encodeURIComponent(String(rateId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all rates
     * 
     * @param cityId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public rates(cityId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<RateCityConf>>;
    public rates(cityId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RateCityConf>>>;
    public rates(cityId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RateCityConf>>>;
    public rates(cityId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling rates.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RateCityConf>>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/rates`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a restriction
     * 
     * @param cityId 
     * @param restrictionId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restriction(cityId: number, restrictionId: number, observe?: 'body', reportProgress?: boolean): Observable<RestrictionConf>;
    public restriction(cityId: number, restrictionId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RestrictionConf>>;
    public restriction(cityId: number, restrictionId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RestrictionConf>>;
    public restriction(cityId: number, restrictionId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling restriction.');
        }
        if (restrictionId === null || restrictionId === undefined) {
            throw new Error('Required parameter restrictionId was null or undefined when calling restriction.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<RestrictionConf>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/restrictions/${encodeURIComponent(String(restrictionId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all the restrictions
     * 
     * @param cityId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public restrictions(cityId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<RestrictionConf>>;
    public restrictions(cityId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RestrictionConf>>>;
    public restrictions(cityId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RestrictionConf>>>;
    public restrictions(cityId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling restrictions.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<RestrictionConf>>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/restrictions`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a schedule
     * 
     * @param cityId 
     * @param scheduleId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public schedule(cityId: number, scheduleId: number, observe?: 'body', reportProgress?: boolean): Observable<ScheduleCityConf>;
    public schedule(cityId: number, scheduleId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ScheduleCityConf>>;
    public schedule(cityId: number, scheduleId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ScheduleCityConf>>;
    public schedule(cityId: number, scheduleId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling schedule.');
        }
        if (scheduleId === null || scheduleId === undefined) {
            throw new Error('Required parameter scheduleId was null or undefined when calling schedule.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ScheduleCityConf>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/schedules/${encodeURIComponent(String(scheduleId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all schedules
     * 
     * @param cityId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public schedules(cityId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ScheduleCityConf>>;
    public schedules(cityId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ScheduleCityConf>>>;
    public schedules(cityId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ScheduleCityConf>>>;
    public schedules(cityId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling schedules.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ScheduleCityConf>>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/schedules`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a segment
     * 
     * @param cityId 
     * @param segmentId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public segment(cityId: number, segmentId: number, observe?: 'body', reportProgress?: boolean): Observable<SegmentConf>;
    public segment(cityId: number, segmentId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SegmentConf>>;
    public segment(cityId: number, segmentId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SegmentConf>>;
    public segment(cityId: number, segmentId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling segment.');
        }
        if (segmentId === null || segmentId === undefined) {
            throw new Error('Required parameter segmentId was null or undefined when calling segment.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<SegmentConf>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/segments/${encodeURIComponent(String(segmentId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all schedules
     * 
     * @param cityId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public segments(cityId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<SegmentConf>>;
    public segments(cityId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SegmentConf>>>;
    public segments(cityId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SegmentConf>>>;
    public segments(cityId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (cityId === null || cityId === undefined) {
            throw new Error('Required parameter cityId was null or undefined when calling segments.');
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<SegmentConf>>(`${this.basePath}/cityConfig/${encodeURIComponent(String(cityId))}/segments`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
