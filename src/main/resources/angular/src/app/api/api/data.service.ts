/**
 * MAAS API
 * This is the Mobility as a Service API
 *
 * OpenAPI spec version: 1.0.0
 * Contact: avalls@nexusgeographics.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import {
    HttpClient, HttpHeaders, HttpParams,
    HttpResponse, HttpEvent
} from '@angular/common/http';
import { CustomHttpUrlEncodingCodec } from '../encoder';

import { Observable } from 'rxjs/Observable';

import { CreditCardStatus } from '../model/creditCardStatus';
import { JuridicEntity } from '../model/juridicEntity';
import { ModifierOrigin } from '../model/modifierOrigin';
import { ModifierType } from '../model/modifierType';
import { NotificationType } from '../model/notificationType';
import { Statistics } from '../model/statistics';
//import { ThirdUserStatus } from '../model/thirdUserStatus';
import { TicketStatus } from '../model/ticketStatus';
import { TicketType } from '../model/ticketType';
import { UserStatus } from '../model/userStatus';
import { ZoneType } from '../model/zoneType';
import { ActivityType } from '../model/activityType';
import { AgreementType } from '../model/agreementType';
import { PeriodicityType } from '../model/periodicityType';




import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';
import { CurrentUserService } from 'app/services/current-user.service';
import { FUNCIONALITIES } from 'app/globalVariables/globalVariables';


@Injectable()
export class DataService {

    protected basePath = 'http://maas.nexusgeografics.com/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(
        private curUser: CurrentUserService,
        protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Creditcard Status
     * 
     * @param authorization 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public creditcardStatus(authorization: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CreditCardStatus>>;
    public creditcardStatus(authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CreditCardStatus>>>;
    public creditcardStatus(authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CreditCardStatus>>>;
    public creditcardStatus(authorization: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling creditcardStatus.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<CreditCardStatus>>(`${this.basePath}/creditcardStatus`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Return Activity Type
     * 
     * @param locale Idioma
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public activityTypeGet(locale: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ActivityType>>;
    public activityTypeGet(locale: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ActivityType>>>;
    public activityTypeGet(locale: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ActivityType>>>;
    public activityTypeGet(locale: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (locale === null || locale === undefined) {
            throw new Error('Required parameter locale was null or undefined when calling activityTypeGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (locale !== undefined && locale !== null) {
            queryParameters = queryParameters.set('locale', <any>locale);
        }

        let headers = this.defaultHeaders;

        // authentication (DUM Token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ActivityType>>(`${this.basePath}/activityType`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all third user status
     * 
     * @param authorization 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    /*public getAllThirdStatus(authorization: string, observe?: 'body', reportProgress?: boolean): Observable<ThirdUserStatus>;
    public getAllThirdStatus(authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ThirdUserStatus>>;
    public getAllThirdStatus(authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ThirdUserStatus>>;
    public getAllThirdStatus(authorization: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getAllThirdStatus.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ThirdUserStatus>(`${this.basePath}/thirdStatus`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }*/

    /**
     * Get all ticket status
     * 
     * @param authorization 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllTicketStatus(authorization: string, observe?: 'body', reportProgress?: boolean): Observable<TicketStatus>;
    public getAllTicketStatus(authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TicketStatus>>;
    public getAllTicketStatus(authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TicketStatus>>;
    public getAllTicketStatus(authorization: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getAllTicketStatus.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<TicketStatus>(`${this.basePath}/ticketStatus`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all ticket types
     * 
     * @param authorization 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllTicketTypes(authorization: string, observe?: 'body', reportProgress?: boolean): Observable<Array<TicketType>>;
    public getAllTicketTypes(authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TicketType>>;
    public getAllTicketTypes(authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TicketType>>;
    public getAllTicketTypes(authorization: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getAllTicketTypes.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<TicketType>(`${this.basePath}/ticketTypes`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all the zone types
     * 
     * @param authorization 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllZoneTypes(authorization: string, observe?: 'body', reportProgress?: boolean): Observable<ZoneType[]>;
    public getAllZoneTypes(authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ZoneType[]>>;
    public getAllZoneTypes(authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ZoneType[]>>;
    public getAllZoneTypes(authorization: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getAllZoneTypes.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ZoneType>(`${this.basePath}/zoneTypes`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all cities
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCities(filter: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<JuridicEntity>>;
    public getCities(filter: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<JuridicEntity>>>;
    public getCities(filter: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<JuridicEntity>>>;
    public getCities(filter: boolean, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        const observable = Observable.create((observer) => {
            let headers = this.defaultHeaders;

            // authentication (MaaS Token) required
            if (this.configuration.accessToken) {
                let accessToken = typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken()
                    : this.configuration.accessToken;
                headers = headers.set('Authorization', 'Bearer ' + accessToken);
            }
    
            // to determine the Accept header
            let httpHeaderAccepts: string[] = [
                'application/json'
            ];
            let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            if (httpHeaderAcceptSelected != undefined) {
                headers = headers.set("Accept", httpHeaderAcceptSelected);
            }
    
            // to determine the Content-Type header
            let consumes: string[] = [
                'application/json'
            ];
    
            this.httpClient.get<JuridicEntity>(`${this.basePath}/cities`,
                {
                    withCredentials: this.configuration.withCredentials,
                    headers: headers,
                    observe: observe,
                    reportProgress: reportProgress
                }
            ).subscribe((cities: any) => {
                if (filter) {
                    cities = cities.filter((city) => {
                        const jurEntities = this.curUser.getUserMunicipis();
                        if (jurEntities && jurEntities.length > 0) {
                            let found = false;
                            for (let i = 0; i < jurEntities.length && !found; i++) {
                                found = jurEntities[i] === city.juridicId;
                            }
                            return found;
                        } else {
                            return true;
                        }
                    });
                }

                observer.next(cities);
                observer.complete();
            }, (err) => {
                observer.error(err);
            });
        });

        return observable;
       
    }

    /**
     * Get all the modifier origins
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modifierOrigins(observe?: 'body', reportProgress?: boolean): Observable<Array<ModifierOrigin>>;
    public modifierOrigins(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModifierOrigin>>>;
    public modifierOrigins(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModifierOrigin>>>;
    public modifierOrigins(observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModifierOrigin>>(`${this.basePath}/modifierOrigins`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all the modifiers types
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modifierTypes(observe?: 'body', reportProgress?: boolean): Observable<Array<ModifierType>>;
    public modifierTypes(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModifierType>>>;
    public modifierTypes(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModifierType>>>;
    public modifierTypes(observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ModifierType>>(`${this.basePath}/modifierTypes`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * /notificationTypes
     * 
     * @param authorization 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public notificationTypes(authorization: string, observe?: 'body', reportProgress?: boolean): Observable<Array<NotificationType>>;
    public notificationTypes(authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<NotificationType>>>;
    public notificationTypes(authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<NotificationType>>>;
    public notificationTypes(authorization: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling notificationTypes.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<NotificationType>>(`${this.basePath}/notificationTypes`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Statistics data for the BO
     * 
     * @param cityId Filter for the data. If not set the service returns all the data.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public statisticsData(cityId?: number, observe?: 'body', reportProgress?: boolean): Observable<Statistics>;
    public statisticsData(cityId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Statistics>>;
    public statisticsData(cityId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Statistics>>;
    public statisticsData(cityId?: number, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (cityId !== undefined) {
            queryParameters = queryParameters.set('cityId', <any>cityId);
        }

        let headers = this.defaultHeaders;

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Statistics>(`${this.basePath}/statisticsStatus`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get user status
     * 
     * @param authorization token
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userStatus(authorization: string, observe?: 'body', reportProgress?: boolean): Observable<UserStatus>;
    public userStatus(authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserStatus>>;
    public userStatus(authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserStatus>>;
    public userStatus(authorization: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling userStatus.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<UserStatus>(`${this.basePath}/userStatus`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }


    /**
   * Return all periodicites
   * 
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
    public periodicity(observe?: 'body', reportProgress?: boolean): Observable<Array<PeriodicityType>>;
    public periodicity(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PeriodicityType>>>;
    public periodicity(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PeriodicityType>>>;
    public periodicity(observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (DUM Token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<PeriodicityType>>(`${this.basePath}/periodicityTypes`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }


    /**
     * Return Activity Type
     * 
     * @param locale Idioma
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public activityType(locale: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ActivityType>>;
    public activityType(locale: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ActivityType>>>;
    public activityType(locale: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ActivityType>>>;
    public activityType(locale: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (locale === null || locale === undefined) {
            throw new Error('Required parameter locale was null or undefined when calling activityType.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (locale !== undefined && locale !== null) {
            queryParameters = queryParameters.set('locale', <any>locale);
        }

        let headers = this.defaultHeaders;

        // authentication (DUM Token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ActivityType>>(`${this.basePath}/activityType`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Agreements
     * Return all Agreements
     * @param locale Idioma
     * @param authorization 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public agreements(locale: string, authorization: string, observe?: 'body', reportProgress?: boolean): Observable<Array<AgreementType>>;
    public agreements(locale: string, authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<AgreementType>>>;
    public agreements(locale: string, authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<AgreementType>>>;
    public agreements(locale: string, authorization: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (locale === null || locale === undefined) {
            throw new Error('Required parameter locale was null or undefined when calling agreements.');
        }

        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling agreements.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (locale !== undefined && locale !== null) {
            queryParameters = queryParameters.set('locale', <any>locale);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (DUM Token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<AgreementType>>(`${this.basePath}/agreements`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }


}
