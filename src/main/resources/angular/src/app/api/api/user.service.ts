/**
 * MAAS API
 * This is the Mobility as a Service API
 *
 * OpenAPI spec version: 1.0.0
 * Contact: avalls@nexusgeographics.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import {
    HttpClient, HttpHeaders, HttpParams,
    HttpResponse, HttpEvent
} from '@angular/common/http';
import { Http, RequestOptions, Headers, URLSearchParams } from '@angular/http';
import { CustomHttpUrlEncodingCodec } from '../encoder';

import { Observable } from 'rxjs/Observable';

import { AccountRequest } from '../model/accountRequest';
import { ApiError } from '../model/apiError';
import { BlockCreditcardRequest } from '../model/blockCreditcardRequest';
import { BlockUserRequest } from '../model/blockUserRequest';
import { CreateAccountResponse } from '../model/createAccountResponse';
import { CreditCard } from '../model/creditCard';
import { OAuthDetails } from '../model/oAuthDetails';
import { OAuthError } from '../model/oAuthError';
import { ResetUserPasswordRequest } from '../model/resetUserPasswordRequest';
import { SupportRequest } from '../model/supportRequest';
import { User } from '../model/user';
import { UserUpdateRequest } from '../model/userUpdateRequest';

import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';
import { query } from '@angular/animations';
import { Service } from '../model/models';
import { SproUserStatus } from '../model/sproUserStatus';


@Injectable()
export class UserService {

    protected basePath = 'http://maas.nexusgeografics.com/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected http: Http, protected httpClient: HttpClient,
        @Optional() @Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Activate a user
     * Activate a user with activationCode are required. If the user is already activated returns an error. 
     * @param activationCode The activation can be done with the activationCode
     * @param authorization Token of authentication
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public activeUser(activationCode: string, authorization: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public activeUser(activationCode: string, authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public activeUser(activationCode: string, authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public activeUser(activationCode: string, authorization: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (activationCode === null || activationCode === undefined) {
            throw new Error('Required parameter activationCode was null or undefined when calling activeUser.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling activeUser.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (activationCode !== undefined) {
            queryParameters = queryParameters.set('activationCode', <any>activationCode);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<any>(`${this.basePath}/users/activate`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Block CreditCard
     * 
     * @param accountID 
     * @param authorization Token of authentication
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public blockCreditcard(accountID: string, authorization: string, body: BlockCreditcardRequest, observe?: 'body', reportProgress?: boolean): Observable<CreditCard>;
    public blockCreditcard(accountID: string, authorization: string, body: BlockCreditcardRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CreditCard>>;
    public blockCreditcard(accountID: string, authorization: string, body: BlockCreditcardRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CreditCard>>;
    public blockCreditcard(accountID: string, authorization: string, body: BlockCreditcardRequest, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (accountID === null || accountID === undefined) {
            throw new Error('Required parameter accountID was null or undefined when calling blockCreditcard.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling blockCreditcard.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling blockCreditcard.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<CreditCard>(`${this.basePath}/accounts/${encodeURIComponent(String(accountID))}/blockCreditcard`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Block or Unblock an user
     * 
     * @param userID 
     * @param authorization Token of authentication
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public blockUser(userID: string, authorization: string, body: BlockUserRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public blockUser(userID: string, authorization: string, body: BlockUserRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public blockUser(userID: string, authorization: string, body: BlockUserRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public blockUser(userID: string, authorization: string, body: BlockUserRequest, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling blockFleetUser.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling blockFleetUser.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling blockFleetUser.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/users/${encodeURIComponent(String(userID))}/block`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add fleet user
     * Add a new fleet user
     * @param accountID 
     * @param authorization Token of authentication
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createFleetUser(accountID: string, authorization: string, body: AccountRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public createFleetUser(accountID: string, authorization: string, body: AccountRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public createFleetUser(accountID: string, authorization: string, body: AccountRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public createFleetUser(accountID: string, authorization: string, body: AccountRequest, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (accountID === null || accountID === undefined) {
            throw new Error('Required parameter accountID was null or undefined when calling createFleetUser.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling createFleetUser.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createFleetUser.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/accounts/${encodeURIComponent(String(accountID))}/fleets`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create (unipersonal or admin fleet) user
     * Create an *unipersonal* or *admin fleet* user and returns an activationCode. Needs to be activated after Ecosistema activation. &#x60;&#x60;&#x60; Create an Account and User entity. &#x60;&#x60;&#x60; 
     * @param authorization Token of authentication
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createUser(authorization: string, body: AccountRequest, observe?: 'body', reportProgress?: boolean): Observable<CreateAccountResponse>;
    public createUser(authorization: string, body: AccountRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CreateAccountResponse>>;
    public createUser(authorization: string, body: AccountRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CreateAccountResponse>>;
    public createUser(authorization: string, body: AccountRequest, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling createUser.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createUser.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (Basic authentication) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<CreateAccountResponse>(`${this.basePath}/accounts`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
  * Return user's active services 
  * @param authorization Token of authentication
  * @param body 
  * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
  * @param reportProgress flag to report request and response progress.
  */
    public getUserServices(authorization: string, userId: string,
        observe?: 'body', reportProgress?: boolean): Observable<Array<Service>>;
    public getUserServices(authorization: string, userId: string,
        observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Service>>>;
    public getUserServices(authorization: string, userId: string,
        observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Service>>>;
    public getUserServices(authorization: string, userId: string,
        observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getUserServices.');
        }

        if (userId === null || authorization === userId) {
            throw new Error('Required parameter userId was null or undefined when calling getUserServices.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (Basic authentication) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.get<any>(`${this.basePath}/users/${userId}/services`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }


    /**
     * Delete user
     * This can only be done on the web. If the user is part of a fleet, only can be done by admin user.
     * @param userID 
     * @param authorization Token of authentication
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteUser(userID: string, authorization: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteUser(userID: string, authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteUser(userID: string, authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteUser(userID: string, authorization: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling deleteUser.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteUser.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/users/${encodeURIComponent(String(userID))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fleet users
     * Returns all the user of a fleet
     * @param accountID 
     * @param authorization Token of authentication
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public fleetUsers(accountID: string, authorization: string, observe?: 'body', reportProgress?: boolean): Observable<Array<User>>;
    public fleetUsers(accountID: string, authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<User>>>;
    public fleetUsers(accountID: string, authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<User>>>;
    public fleetUsers(accountID: string, authorization: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (accountID === null || accountID === undefined) {
            throw new Error('Required parameter accountID was null or undefined when calling fleetUsers.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling fleetUsers.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<User>>(`${this.basePath}/accounts/${encodeURIComponent(String(accountID))}/fleets`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }
	
    /**
     * Logout a specific user
     * This action is used by BO users
     * @param userId 
     * @param authorization Token of authentication
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public logoutUser(userId: number, authorization: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public logoutUser(userId: number, authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public logoutUser(userId: number, authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public logoutUser(userId: number, authorization: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling logoutUser.');
        }

        return this.httpClient.post<any>(`${this.basePath}/users/${encodeURIComponent(String(userId))}/logout`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: null,
                observe: 'response',
                reportProgress: reportProgress
            }
        );
    }


    /**
     * Logs in user
     * Logs in user
     * @param clientId Client id
     * @param grantType Should be password or refresh_token. In case of obtaining new access token use password,
     * @param authorization Basic authorization should include client_id as username and client_secret as password.  String encoding &#x3D; Base64Encoder.encode (\&quot;client_id:client_secret\&quot;);  HttpPost httppost &#x3D; new HttpPost(\&quot;http://host:post/oauth/token\&quot;);  httppost.setHeader(\&quot;Authorization\&quot;, \&quot;Basic \&quot; + encoding);
     * @param refreshToken Required in case of refreshing token
     * @param username LDAP username or MAAS username depends on client specified.  Required in case of obtaining new access token
     * @param password Password of specified user. Required in case of obtaining new access token
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public loginUser(clientId: string, grantType: string, authorization: string, refreshToken?: string, username?: string, password?: string, observe?: 'body', reportProgress?: boolean): Observable<OAuthDetails>;
    public loginUser(clientId: string, grantType: string, authorization: string, refreshToken?: string, username?: string, password?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<OAuthDetails>>;
    public loginUser(clientId: string, grantType: string, authorization: string, refreshToken?: string, username?: string, password?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<OAuthDetails>>;
    public loginUser(clientId: string, grantType: string, authorization: string, refreshToken?: string, username?: string, password?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling loginUser.');
        }
        if (grantType === null || grantType === undefined) {
            throw new Error('Required parameter grantType was null or undefined when calling loginUser.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling loginUser.');
        }
        let formData = '';
        if (clientId !== undefined) {
            formData = 'clientId=' + clientId;
        }
        if (grantType !== undefined) {
            formData = formData + '&grant_type='+  grantType;
        }
        if (refreshToken !== undefined) {
            formData = formData + '&refresh_token='+  refreshToken;
        }
        if (username !== undefined) {
            formData = formData + '&username='+  username;

        }
        if (password !== undefined) {
            formData = formData + '&password=' +  password;
        }

        let headers = new Headers();
        if (authorization !== undefined && authorization !== null) {
            headers.append('Authorization', String(authorization));
        }

        // authentication (Basic authentication) required
        if (this.configuration.username || this.configuration.password) {
            headers.append('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }

        headers.append('Content-Type','application/x-www-form-urlencoded');
        let queryParameters = new URLSearchParams();
        queryParameters.append('client_id', clientId);
        let options = new RequestOptions({
           params : queryParameters,
            headers: headers
        });


        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.http.post(`${this.basePath}/oauth/token`,
            formData,
            options
        );
    }

    /**
     * Resets user&#39;s password
     * Resets user password
     * @param authorization Token of authentication
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public resetPassword(authorization: string, body: ResetUserPasswordRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public resetPassword(authorization: string, body: ResetUserPasswordRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public resetPassword(authorization: string, body: ResetUserPasswordRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public resetPassword(authorization: string, body: ResetUserPasswordRequest, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling resetPassword.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling resetPassword.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/oauth/resetPwd`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get authorization code for email
     * Gets authorization code used to reset password.
     * @param email Email of user
     * @param clientId Client ID
     * @param authorization Token of authentication
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public resetPasswordInfo(email: string, clientId: string, bo:boolean, authorization: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public resetPasswordInfo(email: string, clientId: string, bo:boolean, authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public resetPasswordInfo(email: string, clientId: string, bo:boolean, authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public resetPasswordInfo(email: string, clientId: string, bo:boolean, authorization: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling resetPasswordInfo.');
        }
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling resetPasswordInfo.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling resetPasswordInfo.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (email !== undefined) {
            queryParameters = queryParameters.set('email', <any>email);
        }
        if (clientId !== undefined) {
            queryParameters = queryParameters.set('client_id', <any>clientId);
        }
        queryParameters = queryParameters.set('bo', <any>true);
        

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<any>(`${this.basePath}/oauth/resetPwd`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Request support
     * 
     * @param userID 
     * @param authorization Token of authentication
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public support(userID: string, authorization: string, body: SupportRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public support(userID: string, authorization: string, body: SupportRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public support(userID: string, authorization: string, body: SupportRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public support(userID: string, authorization: string, body: SupportRequest, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling support.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling support.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling support.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/users/${encodeURIComponent(String(userID))}/support`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: 'response',
                reportProgress: reportProgress
            }
        );
    }
	
    /**
     * Unlock an user that it was temporally blocked
     * 
     * @param userId 
     * @param authorization Token of authentication
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public unlockUser(userId: number, authorization: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public unlockUser(userId: number, authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public unlockUser(userId: number, authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public unlockUser(userId: number, authorization: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling unlockUser.');
        }

        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling unlockUser.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<any>(`${this.basePath}/users/${encodeURIComponent(String(userId))}/unlock`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update user
     * 
     * @param userID 
     * @param authorization Token of authentication
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateUser(userID: string, authorization: string, body: UserUpdateRequest, observe?: 'body', reportProgress?: boolean): Observable<User>;
    public updateUser(userID: string, authorization: string, body: UserUpdateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<User>>;
    public updateUser(userID: string, authorization: string, body: UserUpdateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;
    public updateUser(userID: string, authorization: string, body: UserUpdateRequest, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling updateUser.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling updateUser.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateUser.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<User>(`${this.basePath}/users/${encodeURIComponent(String(userID))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

       /**
     * Get User
     * Get user info.
     * @param userId 
     * @param authorization Token of authentication
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userStatus(userId: number, authorization: string, observe?: 'body', reportProgress?: boolean): Observable<SproUserStatus>;
    public userStatus(userId: number, authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SproUserStatus>>;
    public userStatus(userId: number, authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SproUserStatus>>;
    public userStatus(userId: number, authorization: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling user.');
        }

        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling user.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<SproUserStatus>(`${this.basePath}/users/${encodeURIComponent(String(userId))}/status`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get User
     * Only applies fleets, to get info of one specific user.
     * @param userID 
     * @param authorization Token of authentication
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public user(userID: string, authorization: string, observe?: 'body', reportProgress?: boolean): Observable<User>;
    public user(userID: string, authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<User>>;
    public user(userID: string, authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;
    public user(userID: string, authorization: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling user.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling user.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<User>(`${this.basePath}/users/${encodeURIComponent(String(userID))}/detailed`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get user
     * Get user by filters. This method is for helpdesk purpose. **Without query params the method doesn&#39;t return anything**
     * @param authorization Token of authentication
     * @param email To fins one specific user
     * @param userStateID To find inactive users
     * @param phone To find by phone
     * @param document To find by NIF, NIE or passport
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public users(authorization: string, email?: string, userStateID?: number, phone?: string, document?: string, applicationId?:number, observe?: 'body', reportProgress?: boolean): Observable<Array<User>>;
    public users(authorization: string, email?: string, userStateID?: number, phone?: string, document?: string, applicationId?:number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<User>>>;
    public users(authorization: string, email?: string, userStateID?: number, phone?: string, document?: string, applicationId?:number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<User>>>;
    public users(authorization: string, email?: string, userStateID?: number, phone?: string, document?: string, applicationId?:number, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling users.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (email !== undefined) {
            queryParameters = queryParameters.set('email', <any>email);
        }
        if (userStateID !== undefined) {
            queryParameters = queryParameters.set('userStateId', <any>userStateID);
        }
        if (phone !== undefined) {
            queryParameters = queryParameters.set('phone', <any>phone);
        }
        if (document !== undefined) {
            queryParameters = queryParameters.set('document', <any>document);
        }
        if (applicationId !== undefined) {
            queryParameters = queryParameters.set('applicationId', <any>applicationId);
        }
        

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }

        // authentication (MaaS Token) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<User>>(`${this.basePath}/users`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
